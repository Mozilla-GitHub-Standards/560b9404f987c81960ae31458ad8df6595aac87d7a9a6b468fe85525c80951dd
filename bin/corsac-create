#!/usr/bin/env node

var fs = require('fs');
var path = require('path');
var v = require('valentine');
var GitHubApi = require('github');
var github = new GitHubApi({
    // required
    version: "3.0.0",
    // optional
    //debug: true,
    protocol: "https",
    timeout: 5000
});
var ghdownload = require('github-download'); // <-- easy cloning
var exec = require('exec');

var corsac = require('../');

var basename = path.basename(process.cwd());
var templateRepoURL;
var program = corsac.program();

program
	.option('-f, --force', 'force initialization')
	.option('-t, --template [templatename]', 'specify template to use [basic]', 'corsac-template-basic')
	.option('-p, --path [pathname]', 'where to create project [default folder is current folder]', process.cwd())
	.parse(process.argv);


if (fs.existsSync('manifest.webapp') && !program.force) {
  	corsac.fail('An app already exists here. Use -f to overwrite.');
}

corsac.info("Searching GitHub for template: " + program.template + "...");

github.search.repos({keyword: "corsac-template"}, function(err, data) {

	v(data.repositories).each(function(repo) {
		// loop repos searching for the same name
		// to fetch url.
		if (repo.name === program.template) {
			corsac.info("Selected template: " + repo.url);
			templateRepoURL = repo.url;
		}
	});

	ghdownload(templateRepoURL, program.path)
	.on('error', function(err) {
		if (err.code === "ENOTEMPTY") {
			corsac.fail("Destination path is not empty");
		} else {
	  		corsac.fail(err);
	  	}
	})
	.on('end', function() {
	  corsac.ok("App created at " + program.path);
	  process.exit();
	});

});
